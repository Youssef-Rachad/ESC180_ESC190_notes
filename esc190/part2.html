<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YCY17GV3DB');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen" charset="utf-8">

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
    crossorigin="anonymous"
  ></script>
  <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-19048260-11", "auto");
  ga("send", "pageview");

  hljs.highlightAll();
</script>
</head>
<body data-bs-spy="scroll" data-target="#toc">
  <div class="container">
    <div class="row">
      <div class="col-sm-3">
        <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
      </div>
      <div class="col-sm-9">


<h1 id="-esc190-lecture-notes">ESC190 Lecture Notes: Part 2<br> Data Structures and Basic Algorithms</h1>
    <p>See all lecture notes <a href="../">here</a>.</p>
    </p>

<h1 id = "L11">L11: Sorting</h1>
<h2 id="L11-qsort">qsort</h2>
C has a built-in function called qsort that can be used to sort an array of elements. The function takes in 4 arguments:
<ol>
    <li>The array to be sorted</li>
    <li>The number of elements in the array</li>
    <li>The size of each element in the array</li>
    <li>A function that compares two elements in the array. It should return</li>
    <ul>
        <li>A negative number if the first element is smaller than the second element</li>
        <li>0 if the two elements are equal</li>
        <li>A positive number if the first element is larger than the second element</li>
    </ul>
</ol>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int compare_ints(const void *p_a, const void *p_b)
{
  int *p_a_i = (int *)p_a;
  int *p_b_i = (int *)p_b;
  return *p_a_i - *p_b_i;
}

int main()
{
  int arr[] = {6, 5, 10, 2};
  qsort(arr, 4, sizeof(int), compare_ints);
}
</code></pre>
The reason the compare function takes in void pointers is because qsort is a generic function that can be used to sort any type of data. The function then casts the void pointers to the correct type and compares the two elements. This allows us to be more creative. Suppose we have our own structure to represent students, and we wish to sort them by their age. If two students have the same age then we wish to sort them by their name. We can do this by writing a compare function that compares the ages first and then compares the names if the ages are equal. We have,
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct student1{
  char name[20];
  int age;
} student1;

int compare_student1s(const void *p_a, const void *p_b)
{
  // Want to sort student1's by name
  // If students have the same age, sort by name

  student1 *p_a_s = (student1 *)p_a;
  student1 *p_b_s = (student1 *)p_b;
  int age_diff = p_a_s->age - p_b_s->age;
  if(age_diff != 0)
  {
    return age_diff;
  }else{
    return strcmp(p_a_s->name, p_b_s->name);
  }
}

int main()
{
  student1 s1_arr[] = {{"John", 20}, {"Jill", 21}, {"Jack", 21}};

  qsort(s1_arr, 3, sizeof(student1), compare_student1s);

  for (int i = 0; i < 3; i++)
    printf("%s %d\n", s1_arr[i].name, s1_arr[i].age);
}
</code></pre>
Note that:
<ul>
    <li>We can use curly braces to initialize a struct</li>
    <li>The <code>strcmp</code> function compares two strings and returns a negative number if the first string is smaller than the second string, 0 if the two strings are equal, and a positive number if the first string is larger than the second string</li>
</ul>

<h2 id="L11-reading-files">Reading Files</h2>
Quick tip: When copying a file, download it instead of copying and pasting. When copying, you may accidentally ruin the formatting of the file.<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
  FILE *fp = fopen("cities.txt", "r");
  char line[200];
  fgets(line, 200, fp);
  line[strlen(line) - 1] = '\0';
  int num_items = atoi(line);

  return 0;
}
</code></pre>
The code works via the following:
<ol>
    <li>Within <code>main</code>, a file pointer <code>fp</code> is created and is assigned the result of opening the file <code>cities.txt</code> in read mode. If the file doesn't exist, <code>fopen</code> returns <code>NULL</code>.</li>
    <li>A character array <code>line</code> with a maximum size of 200 characters is declared.</li>
    <li>The function <code>fgets</code> is called, which reads a line of text from the file pointed to by <code>fp</code> and stores it in the <code>line</code> array. The maximum number of characters to be read is specified as 200, the second argument to <code>fgets</code>.</li>
    <li>The last character of <code>line</code>, which is the newline character, is replaced with a null terminator (<code>'\0'</code>) to end the string.</li>
    <li>The function <code>atoi</code> is called with <code>line</code> as its argument, which converts the string representation of a number to its integer value. This is <code>93827</code> for the project, the total number of cities.</li>
  </ol>
Alternatively, we can use <code>fgets</code> to read the entire file line by line. This is useful if we want to read the file line by line and do something with each line.

<h1 id="L12-bubble-sort-again">L12: Bubble Sort</h1>
Bubble sort was gone over very quickly last lecture, so this lecture will go over it in more detail.
<h2 id="L12-bubble-sort">Bubble Sort</h2>
Bubble sort is a simple sorting technique that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements "bubble" to the top of the list. The pseudocode is given by (from Wikipedia),<br><br>
<pre>
function bubbleSort(L)
    n = length(L)
    repeat
        swapped = false
        for i=1 to n-1 inclusive do
            /* if this pair is out of order */
            if A[i-1] > A[i] then
                /* swap them and remember something changed */
                swap(A[i-1], A[i])
                swapped = true
            end if
        end for
    until not swapped
end function
</pre>
<div class="card">
  <h3 class="card-header">Exercise</h5>
  <div class="card-body">
    Consider the below sequence. Manually apply bubble sort:
    <pre>
5, 2, 10, 56, 15
    </pre>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    Each line represents a different step:
<pre>
5, 2, 10, 56, 8
2, 5, 10, 56, 8 // 2 and 5 swapped
2, 5, 10, 56, 8 // 5 and 10 in order
2, 5, 10, 56, 8 // 10 and 56 in order
2, 5, 10, 8, 56 // 56 and 8 swapped
// Go back to beginning
2, 5, 10, 8, 56 // 2 and 8 in order
2, 5, 10, 8, 56 // 5 and 10 in order
2, 5, 8, 10, 56 // 8 and 10 swapped
2, 5, 8, 10, 56 // 10 and 56 in order
// Go back to beginning
2, 5, 8, 10, 56 // 2 and 5 in order
2, 5, 8, 10, 56 // 5 and 8 in order
2, 5, 8, 10, 56 // 8 and 10 in order
2, 5, 8, 10, 56 // 10 and 56 in order
</pre>
</div></div></div></div>
In C, it can be implemented as,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void bubble_sort(void *arr, int num_items, int item_size,
                 int (*compare)(const void *, const void *))
{
  int i, j;
  void *temp = malloc(item_size);

  for (i = 0; i < num_items - 1; i++){
    for (j = 0; j < num_items - i - 1; j++){
      // compare arr[j] and arr[j + 1], swap if necessary
      // arr[j] only makes sense if array is of type int*, float*, etc.
      void *p_j = arr + j * item_size;
      void *p_j1 = arr + (j + 1) * item_size;

      // Now can compute compare(p_j, p_j1)
      if (compare(p_j, p_j1) > 0){
        // kind of want to swap *p_j and *p_j1
        memcpy(temp, p_j, item_size); // temp = *p_j
        memcpy(p_j, p_j1, item_size);
        memcpy(p_j1, temp, item_size);
      }
    }
  }
  free(temp);
}

int compare_int(const void *p_a, const void *p_b)
{
  const int *x = (const int *)p_a;
  const int *y = (const int *)p_b;
  return *x - *y;
}

int main()
{
  int arr[] = {64, 34, 25, 12, 22, 11, 90};
  int num_items = sizeof(arr) / sizeof(arr[0]);
  bubble_sort(arr, num_items, sizeof(int), compare_int);

  for (int i = 0; i < num_items; i++)
    printf("%d ", arr[i]);

  return 0;
}
</code></pre>
Here are some comments about the signature of the <code>bubble_sort</code> function:
<ul>
    <li><code>void *arr</code>: This is a pointer to the array to be sorted. The data type of the array is not specified, so the function can be used with arrays of any data type.
    </li>
    <li><code>int (*compare)(const void *, const void *)</code> is a pointer to a comparison function. The comparison function takes two pointers to void as arguments and returns an integer less than, equal to, or greater than zero, depending on the result of the comparison. This allows the function to be used with arrays of any data type and to sort the array in any order.</li>
</ul>
Note that when we swap two elements in the array, we need to use the <code>memcpy</code> function to copy the data from one element to another. This is because we don't know the data type of the elements in the array.<br><br>The <code>memcpy</code> function takes three arguments: the destination, the source, and the number of bytes to copy. The destination and source are both pointers to void, so we can use the <code>swap</code> function with arrays of any data type.
<div class="card">
  <h3 class="card-header">Exercise</h5>
  <div class="card-body">
    Consider the above code. It is actually inefficient and not the most ideal implementation of bubble sort. Why? (Hint: Compare this to the pseudocode)
<br><br>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    There is no stop condition. If the array is somehow fully sorted halfway into the program, it will still run to the very end (even if you pass in an already sorted array!)
  </div>
</div>
</div>
</div>
<h2 id="detailed-bubble-sort">Optimizing Bubble Sort</h2>
We can modify the program such that if a full pass through the array is made without any swaps, then the array is already sorted and we can stop the program. This can be done by modifying the <code>bubble_sort</code> function as follows:
<pre><code class="language-C">void bubble_sort(void *arr, int num_items, int item_size,
                 int (*compare)(const void *, const void *))
{
  int i, j;
  void *temp = malloc(item_size);

  for (i = 0; i < num_items - 1; i++)
  {
    int swapped = 0;
    for (j = 0; j < num_items - i - 1; j++)
    {
      // compare arr[j] and arr[j + 1], swap if necessary
      // arr[j] only makes sense if array is of type int*, float*, etc.
      void *p_j = arr + j * item_size;
      void *p_j1 = arr + (j + 1) * item_size;

      // Now can compute compare(p_j, p_j1)
      if (compare(p_j, p_j1) > 0)
      {
        // kind of want to swap *p_j and *p_j1
        memcpy(temp, p_j, item_size); // temp = *p_j
        memcpy(p_j, p_j1, item_size);
        memcpy(p_j1, temp, item_size);
        swapped = 1;
      }
    }
    if (!swapped){
      break; // return could cause a memory leak
             // could go free(temp) and return
    }
  }
  free(temp);
}
</code></pre>

<h1 id="L18">L18: Consts and Linked Lists</h1>
<h2 id="L18-Const">The const keyword</h2>
<ul>
  <li><code>const</code> indicates that a value is not to be changing. Changing a <code>const</code> value could result in a compilation warning or warning. The intended purpose is to help catch errors in the code earlier. Consider:
<pre><code class="C">const char c = 42;
c = 43; // compilation error

const char *p_c = (char*)malloc(sizeof(char));
*p_c = 0; // compilation error
p_c = "hello"; // fine
</code></pre>
  </li>
  <li>In the second part of the above example, we demonstrate that we are not allowed to modify the contents of
    the memory at the address p_c. However, we can assign the pointer <code>p_c</code> to point to a string literal <code>"hello"</code>. This is allowed because the pointer itself is not modified, only the memory location it points to. </li>
  <li>String literals like <code>"hello"</code> are of type <code>const char*</code></li>
  <li>Sometimes, we wish to not be able to change the address, but be able to go to the address and change the contents. We can achieve that via the following:
<pre><code class="C">int * const p_n = (int*)malloc(sizeof(int))
p_n = 0; // error
*p_n = 1; // fine
</code></pre>
  </li>
  <li>Similarly, we can disallow changing both the address and the contents (but this is usually not done)
<pre><code class="C">const int * const p_n = (int*)malloc(sizeof(int))
p_n = 0; // error
*p_n = 1; // error
</code></pre>
  </li>
</ul>
We can apply the <code>const</code> keyword to write our student2 structure as follows:
<pre><code class="C">typedef struct student2{
    const char *name;
    const int *p_age;
} student2;</code></pre>
When an instance of this struct is created, the <code>const</code> keyword tells us we are reserving a place in memory for the address of the age and the address of the name. Like before, we cannot change the name like
<pre><code class='c'>void change_name_wrong(student2 *p_s)
{
    p_s->name[0] = 'b';
}</code></pre>
since <code>p_s->name[0],p_s->name[1],</code> etc. are read-only (cannot change the value of the memory at the pointer). The above code attempts to go to the address and change the value at that address (which can't be done, since it's a const), while doing something like
<pre><code class='c'>void change_name_right(student2 *p_s)
{
    p_s->name = "b";
}</code></pre>
is fine since we are not changing the value at the address, but rather the address itself.
<h2 id="L18-Linked-Lists">Linked Lists</h2>
Motivation: We cannot dynamically add an element to an existing array or block of memory easily, as there could be no space there! The only option we have is to re-allocate everything to a new location with enough space. This is inefficient, especially for larger arrays. Instead, we can use a special data structure called a <b>linked list</b>.
<ul>
  <li>A linked list consists of a data structure called a <code>node</code>, which consists of the following information:</li>
  <ul>
    <li><code>data:</code> the actual data you need to store</li>
    <li><code>next:</code> the address of the next node</li>
  </ul>
  <li>We can then make an array by creating a chain of these nodes, where we can find the next node by following the <code>next</code> pointer. While this uses up more space than a regular array, it has the benefit of preventing re-allocating everything. For example, if we want to add an element to the end of the list, we can simply create a new node and set the <code>next</code> pointer of the last node to point to the new node (+ a minor detail we'll touch on in a bit). </li>
  <li>See the <a href="https://www.cs.toronto.edu/~guerzhoy/190/lec/W07/LL.pdf">lecture slides</a> for a visual of linked lists and their operations.</li>
</ul>
<h2 id="L18-LL-operations">Linked List Operations</h2>
We want to implement the following operations: Inserting, Removing, and Searching.
<ul>
  <li>Inserting: Suppose we already have a pointer to a node, and we wish to insert a node after that. What we can do is create this new node, and set its <code>next</code> pointer to point to the node that the original node pointed to. Then, we can set the original node's <code>next</code> pointer to point to the new node we just created.</li>
  <ul><li><b>Analogy:</b> A popular children's activity is to form a <i>human train,</i> where each person puts their hand on the shoulder of the person in front of them, forming a chain (linked list). If a new participant Bob (the new node) wants to join the train in front of Alice (who is holding Carol's shoulder), Bob can do so by holding onto Carol's shoulder, and then Alice can hold onto Bob's shoulder. </li></ul>
  <li>Removing: Suppose we already have a pointer to a node, and we wish to delete that node. We can do so by setting the <code>next</code> pointer of the node before the node we want to delete to point to the node after the node we want to delete. Finally, we free up the memory.</li>
  <ul><li><b>Analogy:</b> If Bob wants to leave the train, he can simply let go of Carol's shoulder, and Alice can hold onto Carol's shoulder. </li></ul>
  <li>Getting: Suppose we wish to find a node (i.e. its pointer) at a certain index (i.e. the <code>i</code>th node) In the previous 2 operations, we assumed we already had this pointer. We can do so by iterating through the linked list by following the <code>next</code> pointer until we find the node we want. </li>
  <ul><li><b>Analogy:</b> If a teacher wants to find the 7th student, they can start from the very beginning of the train and follow it to the end until the 7th student is found.</li></ul>
  </li>
</ul>
In summary, we can delete and insert nodes in constant time, which is faster than array operations which are O(n). However, getting the <code>i</code>th node is linear time, while we can do that in constant time for arrays.
<h2 id="L18-LL-implementation">Linked List Implementation</h2>
We can implement the linked list as follows:
<pre><code class="c">#include &lt;stdio.h&gt
#include &lt;string.h&gt
#include &lt;stdlib.h&gt

typedef struct node{
    int data;
    struct node *next;
} node;

typedef struct LL{
    node *head;
    int size;
} LL;

void create_node(node **p_n, int data)
{
    *p_n = (node*)malloc(sizeof(node));
    (*p_n)->data = data;
    (*p_n)->next = NULL;
}


void create_LL_from_data(LL **p_LL, int *data_arr, int size)
{
    (*p_LL) = (LL*)malloc(sizeof(LL));
    (*p_LL)->size = 0; // initialize size to 0

    // keep track of the last node of the linked list
    node *tail = 0;

    for(int i = 0; i < size; i++){

        // n is a pointer to a node with data = data[i], next = NULL
        node *n;
        create_node(&n, data_arr[i]);

        // If the last node is the 1st node
        if(tail == 0){
            (*p_LL)->head = n;
        }

        // If the last node is not the 1st node
        else{
            // append the new node to the end of the linked list
            tail->next = n;
        }

        // update the tail
        tail = n;

        // update the size
        (*p_LL)->size++;
    }
}

int main(){
    int data_arr[] = {1, 2, 3, 4, 5};
    LL *p_LL;
    create_LL_from_data(&p_LL, data_arr, 5);
}</code></pre>
Here are some observations:
<ul>
<li>The idea behind the <code>create_LL_from_data</code> function is to keep track of the last node of the linked list (known as the tail) and constantly update it such that every time we create a new node, the tail's <code>next</code> pointer points to the new node. </li>
<li>Initializing a new node like <code>node *n</code> will cause the <code>next</code> pointer to be <code>0</code> i.e. <code>NULL</code>. This is how we can tell we reached the end of a linked list.</li>
</li>
<li>we need to use pointers to pointers because we want to be able to modify the value of the <code>LL</code> pointer (i.e. the memory address it points to), rather than just the value of the data it points to.</li>
</ul>
<h1 id="L19">L19: Abstract Data Type</h1>
An <b>abstract data type</b> (ADT) is any collection of values, together with operations on those values. For example:
<ul>
  <li><code>ints</code> with operations <code>+,-*,/,%</code></li>
  <li><code>lists</code> with operations insert, remove, get</li>
</ul>
An ADT specifies what values are represented and what operations can be performed, but not how to store them or how to carry them out. They allow for modularity and reuse, as it is independent of implementation. A <b>data structure</b> is an implementation of an ADT as it is a way to represent the values, and algorithms for each operation.<br><br>

Example: Consider a <code>list</code> which is an ordered collection of data items that supports the following operations:
<ul>
  <li><code>Insert(list, i, x)</code>: add item <code>x</code> at index <code>i</code> of <code>list</code>. The item previously at index <code>i</code>, and all following items, are shifted up by one index to make room for <code>x</code>.</li>
  <li><code>Remove(list, i)</code>: remove item at index <code>i</code> of <code>list</code>. The item previously at index <code>i+1</code>, and all following items, are shifted down by one index to fill the gap.</li>
  <li><code>Get(list, i)</code>: return the item at index <code>i</code> of <code>list</code>.</li>
</ul>
We define this ADT very abstractly, such that we only describe the outcome of each operation, but not how to implement it. For example, lists can be implemented using arrays, but it can also be implemented using linked lists.
<h2 id="L19-LL-insert">Insert for Linked List</h2>
In the previous lecture, we defined the linked list struct as follows:
<pre><code class="c">typedef struct node{
  int data;
  struct node *next;
} node;

typedef struct LL{
  node *head;
  int size;
} LL;
</code></pre>
We also talked about how to implement insertions conceptually. We can implement it as follows:
<pre><code class="c">
void LL_insert(LL *my_list, int new_elem, int index)
{
  // Create the new node
  node *n;
  create_node(&n, new_elem);

  // If the list is empty
  if(my_list->head == NULL){
    my_list->head = n;
    my_list->size++;
    return;
  }

  // To insert at the very beginning
  if(index == 0){
    n->next = my_list->head;
    my_list->head = n;
    my_list->size++;
    return;
  }

  // Errors
  if (index < 0 || index > my_list->size-1){
    fprintf(stderr, "Invalid index %d", index);
    exit(1); // exits the program, returns 1 to the OS
  }

  // Traverse to the desired index
  node *cur = my_list->head;
  for(int i = 0; i < index; i++){
    cur = cur->next;
  }

  n->next = cur->next;
  cur->next = n;
  my_list->size++;
}
</code></pre>
Note that we deal with a few edge cases:
<ul>
  <li>If the list is empty, which we can check if the head is <code>NULL</code>, then we proceed to make the new node the first (and only) element of the linked list.</li>
  <li>We want to implement it such that inserting it at index <code>0</code> corresponds to inserting it at the very beginning. To do this, not only do we need to update the <code>next</code> pointer of the new node, but the <code>head</code> pointer of our linked list. The order here is important. If we instead ran <code>my_list->head = n;</code> first, we lose information on where the original head is located.</li>
  <li>If the index is invalid, there are a few possibilities of what we can do.<ol>
    <li>Just Crash: Sometimes this is a good idea, if we are trying to optimize the code. It's on the user to give valid parameters.</li>
    <li>Don't crash and don't insert. Instead, set a global variable to indicate an error. The reason we need a global variable here is that there's no other thing we can return that will indicate this. For example, if we are trying to return the element at an invalid index, a naive idea would be to return something like <code>-1</code> or <code>"Error"</code>, but how do we know that this is actually an error and their list doesn't actually include this!</li>
    <li>Print an error message. In particular the best way to print an error is using <code>fprintf(stderr, "message")</code> because it prints to the standard error stream, which is different from the standard output stream. Unlike <code>printf</code> (which sometimes doesn't show in terminal), this will always show, and allows regular print statements and error messages to be separated.</li>
  </ol>

  </li>
</ul>
In the other cases, we first need to traverse to the desired index. Because this is not an array, we need to follow the linked list via the <code>next</code> pointers. Once we reach the desired index, we can update the <code>next</code> pointers of the new node and the node before it. Similar to above, the order of updating the <code>next</code> pointers matter!
<h2 id="L19-LL-remove">Remove and Get for Linked List</h2>
The code to remove and get for linked lists can be found <a href="https://www.cs.toronto.edu/~guerzhoy/190/labs/linkedlist.c">here</a> and is very similar to the code for insert. For deletion, we just need to remember to update the <code>next</code> pointer of the node before the one we are deleting, and freeing up the memory. Like most cases, the order here is important.

Getting is actually partially implemented in insertion and deletion, as we need to find the <code>i</code>th element. Error handling for all three functions are also similar.
<h2 id="L19-Coding-Practices">Good Coding Practices</h2>
Suppose you have a piece of code, that relies on an abstract data structure (i.e. a list). We can define this structure in a header file <a href="https://www.cs.toronto.edu/~guerzhoy/190/labs/list.h">list.h</a>. Recall that an ADT doesn't include how it is implemented, just the operations. <br><br>

We can now implement this ADT in a separate file. For example, we can either implement it using <a href="https://www.cs.toronto.edu/~guerzhoy/190/labs/linkedlist.c">linkedlist.c</a> or <a href="https://www.cs.toronto.edu/~guerzhoy/190/labs/arraylist.c">arraylist.c</a>. For example, if our <code>list.h</code> file looks like
<pre><code class="c">#if !defined(LIST_H)
#define LIST_H
void create_list_from_data(void **p_list, int *data_arr, int size);
void list_append(void *list, int new_elem);
void list_insert(void *list, int new_elem, int index);
void list_delete(void *list, int index);
void list_free_all(void *list);
int list_get(void *list, int index);
#endif</code></pre> Then our <code>linkedlist.c</code> file needs to contain these functions. If we already have code (i.e. the earlier ones we wrote), we don't need to modify them. Instead, we can just create a new function that calls them in order to have the right form. For example,
<pre><code class="c">void list_insert(void *list, int new_elem, int index)
{
    LL_insert((LL*)list, new_elem, index);
}

int list_get(void *list, int index)
{
    return LL_get(list, index);
}</code></pre>
Notice that the functions in <code>list.h</code> take in void pointers, because we want them to be as general as possible (i.e. could be implemented using either an array or linked list). These additional functions we write in <code>linkedlist.c</code> are just wrappers. One final note is that although we can cast the void pointer to the correct type <code>(LL*)</code>, it is not necessary.<br><br>

We can do this for both <code>linkedlist.c</code> and <code>arraylist.c</code>, and when we want to compile our main program, we can choose to compile it with either <code>linkedlist.c</code> or <code>arraylist.c</code>. For example, we can run
<pre><code class="language-bash">gcc linkedlist.c -c -o linkedlist.o</code></pre>
to create the object file <code>linkedlist.o</code>. We can then compile <code>main.c</code> alongside <code>linkedlist.o</code> to create an executable. We can do this by running
<pre><code class="language-bash">gcc main.c linkedlist.o -o main</code></pre>
If we instead wanted to compile using the array list implementation, we can run
<pre><code class="language-bash">gcc main.c arraylist.o -o main</code></pre>
This has several advantages:
<ul>
  <li>Modularity and Reusability: When writing our main code, we don't have to worry about how certain functions are implemented. Also, if we already have code that can implement abstract data structures, we can just re-use them for future projects without changing too much!</li>
  <li>Faster compilation: Using a precompiled object like <code>linkedlist.o</code> can save compilation time. Although this is not a big problem now, compilation time can be an issue for larger and more complex projects.</li>
</ul>
<h2 id="L19-Python">Python Classes</h2>
Structures in C are similar to classes in Python (Classes in Python are actually much much more powerful, but that's not the point in this section). We can define a <code>Student</code> class in Python as follows,
<pre><code class="language-python">class Student:
  def __init__(self, name, gpa):
      self.name = name
      self.gpa = gpa

  def __str__(self):
      return self.name + ": " + str(self.gpa)
if __name__ == "__main__":
  s = Student('Fred', 3.7)
  print(s.name, s.gpa)
</code></pre>
Here, <code>__str__</code> is a built-in function, and we can call it via either:
<pre><code class="python">s.__str__()
Student.__str__(s)
</code></pre>
Here, the first line is just shorthand notation for the second line. What makes this built-in function useful is that we can call <code>print(s)</code> and it will treat this as <code>print(s.__str__())</code> instead.<br><br>

We can also write a function to compare two classes, so that we can use operators such as <code><</code>, <code>></code>, and <code>==</code>. For example,
<pre><code class="language-python">class Student:
  def __init__(self, name, gpa):
      self.name = name
      self.gpa = gpa

  def __str__(self):
      return self.name + ": " + str(self.gpa)

  def __lt__(self, other):
      # Return True if self has lower gpa than other
      # If GPAs are tied, compare names

      if self.gpa < other.gpa:
        return True
      elif self.gpa == other.gpa:
        return self.name < other.name
      else:
        return False
if __name__ == "__main__":
  fred = Student('Fred', 3.7)
  bob = Student('Bob', 2.0)
  print(Student.__lt__(fred, bob))
  print(fred < bob)
</code></pre>
Recall that this is very similar to the compare function we wrote for <code>qsort.</code> Because we can compare different students, we can also sort them using the default sorted function in Python. For example,
<pre><code class="language-python">L = [Student("Fred", 3.7"), Student("Bob", 3.7), Student("Alice", 3.9)]
L.sort()
print(L) # [Bob: 3.7, Fred: 3.7, Alice: 3.9]
</code></pre>
will allow us to sort and print out the list of students in a very convenient way (using both the custom print and compare functions we wrote)!

Note that this is a more flexible method of sorting classes in Python. The "traditional" way (for simple comparison functions), we will write a function to get a numerical value from the class and sort using that key. For example,
<pre><code class="python">def get_name(s):
  return s.name
L.sort(key=get_name)
</code></pre>
will sort the list of students in <code>L</code> alphabetically. Alternatively, we can use anonymous functions (lambda functions) which we can write in one line to save space. For example,
<pre><code class="python">L.sort(key=lambda s: s.name)</code></pre>
achieves the same purpose.<br><br>

However, it is difficult (but not impossible) to modify the "traditional" way and come up with a way to map a more complicated comparison function to a numerical value. Note: comparison functions can be as complex as we want, but they need to be <i>transitive</i> in order to get meaningful results.





<h1 id="L20">L20: Precedence</h1>
Recall the standard order of operations for arithmetic expressions. For example,
\[1 + 2 * 8 = 17\]
and C will treat this completely normally. However, there are some unintuitive cases when dealing with other operators in C, which we will discuss in this lecture.
<h2 id="L20-plus-plus">++ Operator</h2>
Recall the <code>++</code> operator, which increments a variable by 1. Specifically, it is a post increment operator, meaning that it increments the variable after it is evaluated. For example, consider the following code,
<pre><code class='c'>int a = 6;
int b = 7 + a++; // make b = 7+a, and then increment a by 1
</code></pre>
Note that adding parentheses here doesn't matter, since the <code>++</code> operator is already the highest precedence (see <a href="https://en.cppreference.com/w/c/language/operator_precedence">precedence list</a>). Therefore, the code
<pre><code class='c'>int a = 6;
int b = 7 + (a++); // make b = 7+a, and then increment a by 1
</code></pre>
will give the same behaviour, which is not intuitive at first! Now consider something similar,
<pre><code class='c'>char *s = "hello";
printf("%c", *(s++)); // incrementing the address
                      // what happens with just *s++
printf("%c", (*s)++); // incrementing the value at address s
                      // 'h' becomes 'i'
</code></pre>
The first case is what happens if we don't have any parentheses at all (since <code>++</code> has highest precedence). Note that the second case here may lead to a segmentation fault.<br><br>

This notation can be very useful, and can be used to write certain functions in a very fast way (see L7). For example, if we want to copy a string, we can do the following:
<pre><code class='c'>char *s = "hello";
char dest[10];
char *dest_write = dest;
// want to copy string s into dest
while(*dest_write++ = *s++);
</code></pre>
The while loop is the only thing we need. There are a few things to note here:
<ul>
  <li>The value of an "assignment relation" is equal to the value assigned. Therefore, the while loop will continue to run as long as <code>*s</code> is not <code>NULL</code>. In general, any non-zero value is true and any zero value (including NULL) is false.</li>
  <li>The notation <code>*dest_write++ = *s++</code> tells us to assign the value of <code>*s</code> to <code>*dest_write</code>, then the <code>++</code> operator tells us to increment both pointers AFTER the assignment happens.</li>
</ul>
While this works, it is usually not a good practice as you have to be very careful about the order of operations and think about things. It's included here for you to understand it exists and see it once, but please don't use this in your code when you could write more readable code in just a few extra lines.
<h1 id="L21">L21: Linked Lists II</h1>
In this lecture, we will discuss how to implement a linked list in Python. Most of the time, you won't need to use a linked list in Python (we'll see an example next Monday), but it is still important to understand how linked lists work, and the work done in this lecture will be useful for implementing other data structures in Python for the rest of this course. The advantage of Python over C is pedagogical here, we want to focus on the data structure and not the specific implementation details.<br><br>

If you are not familiar with classes, please see the last part of L19. Consider the Node class,
<pre><code class="python">class Node:
  def __init__(self, value):
      self.value = value
      self.next = None

  def __str__(self):
      return f"{self.value}"</code></pre>
By default, we have set <code>self.next = None</code> to indicate that the next node is not yet defined. We can then create a linked list by creating a series of nodes and linking them together. For example,
<pre><code class="python">if __name__ == '__main__':
  n1 = Node(12)
  n2 = Node(15)
  n3 = Node(500)

  n1.next = n2
  n2.next = n3</code></pre>
Recall that in the Python memory model, values are not copied. Everything is passed by reference. Therefore, something like <code>n1.next = n2</code> means we make <code>n1.next</code> refer to the address of <code>n2</code> (so they are treated as the "same" thing). In C, the analogy would be
<pre><code class="c">node *n1 = create_node(12)
node *n2 = create_node(15)
n1->next = n2;
</pre></code>
where the function <code>create_node()</code> performs the memory allocation for you, which is what Python is doing behind the scenes. We can also make a linked list class and include some functions. For example,
<pre><code class="python">class LinkedList:
  def __init__(self):
      self.head = None

  def get_i(self, i):
      # return the value at index i
      cur = self.head
      for j in range(i):
          cur = cur.next
      return cur.value

  def append(self, value):
      '''Add a new node with the value value to the end of the list'''
      # Create a new node
      new_node = Node(value)
      print(new_node)

      if self.head == None:
          self.head = new_node
      else:
          # Find the last node
          cur = self.head
          while cur.next != None:
              cur = cur.next
          cur.next = new_node

  def insert(self, value, i):
      '''Insert a node with the value value at index i'''
      new_node = Node(value)

      if i == 0:
          new_node.next = self.head
          self.head = new_node
      else:
          cur = self.head
          for j in range(i-1):
              cur = cur.next
          new_node.next = cur.next
          cur.next = new_node

  def __str__(self):
      cur = self.head
      s = ""
      if(cur == None):
          return "Empty list :("

      while cur != None:
          s += str(cur) + " -> "
          cur = cur.next
      return s[:-4] # remove last arrow</code></pre>
Note that we didn't do anything new here. We took the existing code we had in L18 and transformed it into Python equivalents. The only new thing is the <code>__str__</code> function, which allows us to easily print out the linked list. For this function we have two cases: if the list is empty, we print something, and if the list is non-empty we print out the values of each node, connected with the -> symbol. We can then test our code,
<pre><code class="python">if __name__ == '__main__':
  LL = LinkedList()
  LL.append(3)
  LL.append(50)
  LL.append(100)

  print(LL)</code></pre>
<h1 id = "L22">L22+ Onwards</h1>
See <a href="part3.html">Part 3</a>.

<br><br><br><br><br>

  </body>
</html>
