<!DOCTYPE html>
<html>
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-YCY17GV3DB');
    </script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous" />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen"
        charset="utf-8">

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
        integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
        crossorigin="anonymous"></script>
    <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

    <script type="text/javascript">
        (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
                i[r] ||
                function () {
                    (i[r].q = i[r].q || []).push(arguments);
                }),
                (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
        })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
        );

        ga("create", "UA-19048260-11", "auto");
        ga("send", "pageview");

        hljs.highlightAll();
    </script>
</head>

<body data-bs-spy="scroll" data-target="#toc">
    <div class="container">
        <div class="row">
            <div class="col-sm-3">
                <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
            </div>
            <div class="col-sm-9">

                <h1 id="graphs>Graphs</h1>
                We've already seen graphs twice: we've seen both heaps and linked lists. In general,
                <div class=" alert alert-success" role="alert"><br>
                    A <b>graph</b> \(G=(V,E)\) is an ADT that consists of a set of vertices (nodes) \(V\) and a set of
                    edges \(E\).
                </div>
            </div>
            For example, the following is a graph,
            <center>
                <script type="text/tikz">
    \begin{tikzpicture}[scale=3]
    \tikzstyle{vertex}=[circle,fill=black!25,minimum size=40pt,inner sep=2pt]

    \node[vertex] (A) at (0,1.8)  {A};
    \node[vertex] (B) at (0.8,0.6)  {B};
    \node[vertex] (C) at (0.3,-0.7)  {C};
    \node[vertex] (D) at (-0.7,-0.4)  {D};
    \node[vertex] (E) at (-0.8,0.8)  {E};

    \draw (A) -- node[midway, above right] {edge 1} (B);
    \draw (B) -- node[midway, right] {edge 2} (D);
    \draw (B) -- node[midway, right] {edge 3} (C);
    \draw (C) -- node[midway, below left] {edge 4} (E);
    \end{tikzpicture}
</script>
            </center>
            where
            \[
            \begin{align*}
            G &= (V,E) \\
            V &= \{v_1, v_2, v_3, v_4, v_5\} \\
            E &= \{e_1, e_2, e_3, e_4, e_\} \\
            e_1 &= (v_1, v_2) \\
            e_2 &= (v_2, v_3) \\
            e_3 &= (v_2, v_4) \\
            e_4 &= (v_3, v_5)
            \end{align*}
            \]
            Here, the edges can either be undirected or directed. If no arrows are drawn, we assume the edges are
            undirected (so we can travel from \(v_1\) to \(v_2\) and from \(v_2\) to \(v_1\)) and we treat \((v_1,v_2)\)
            as an unordered pair.<br><br>

            Why might we use graphs?
            <ul>
                <li>Vertices are cities, edges are direct flights between cities: Want to find the best route between
                    cities</li>
                <ul>
                    <li>Reformulate: Find the shortest distance between two nodes on a graph</li>
                </ul>
                <li>Vertices are school classes, edges connect classes whose schedules overlap: Want to find scheduling
                    times/locations for classes</li>
                <ul>
                    <li>Reformulate: Find a set of nodes that are completely disconnected from each other (i.e. no two
                        nodes share an edge)</li>
                </ul>
                <li>
                    Vertices are objects in memory, edges connect objects that refer to each other: Want to know when an
                    object can be freed
                </li>
                <ul>
                    <li>Reformulate: Find the set of nodes that connect to a certain node</li>
                </ul>
            </ul>
            as just a few examples. The reason this is important is that there are already standard algorithms for
            dealing with these types of problems, so if we can take our problem and reformulate it as a graph problem,
            we automatically get the solution. Some different types of graphs:
            <ul>
                <li><b>Directed Graphs ("digraphs"):</b> Edges have directions associated with them</li>
                <center>
                    <script type="text/tikz">
    \begin{tikzpicture}[scale=2]
    \tikzstyle{vertex}=[circle,fill=black!25,minimum size=40pt,inner sep=2pt]

    % Define the nodes with labels
    \node[vertex] (1) at (2,2)  {Node 1};
    \node[vertex] (2) at (3,1)  {Node 2};
    \node[vertex] (3) at (0,1)  {Node 3};
    \node[vertex] (4) at (2,0)  {Node 4};

    % Draw the edges and label them
    \draw[->] (2) -- node[midway, above] {Edge 1} (1);
    \draw[->] (1) -- node[midway, above] {Edge 2} (3);
    \draw[->] (3) -- node[midway, right] {Edge 3} (4);
    \draw[->] (4) -- node[midway, left] {Edge 4} (3);
    \draw[->] (4) -- node[midway, below] {Edge 5} (1);

    \end{tikzpicture}
</script>
                </center>
                Here, we write \(e_1 = (v_2,v_1)\) where the order matters now. The first element is the predecessor (or
                source) and the second element is the successor (or target).
                <li><b>Weighted graphs:</b> Each edge has a weight associated to it</li>
                <center>
                    <script type="text/tikz">
    \begin{tikzpicture}[scale=2]
    \tikzstyle{vertex}=[circle,fill=black!25,minimum size=40pt,inner sep=2pt]

    % Define the nodes with labels
    \node[vertex] (1) at (3, 1)  {Node 1};
    \node[vertex] (2) at (2, 2)  {Node 2};
    \node[vertex] (3) at (2, 0)  {Node 3};
    \node[vertex] (4) at (4, 1)  {Node 4};

    % Draw the edges and label them
    \draw (1) -- node[midway, above] {30} (2);
    \draw (1) -- node[midway, below] {45} (3);
    \draw (1) -- node[midway, above] {60} (4);
    \draw (2) -- node[midway, right] {25} (3);
    \draw (2) -- node[midway, above] {10} (4);
    \draw (3) -- node[midway, below] {20} (4);

    \end{tikzpicture}
</script>
                </center>
            </ul>
            and some terminology:
            <ul>
                <li>Vertex \(v_1\) is <b>adjacent</b> to vertex \(v_2\) if an edge connects them.</li>
                <li>A <b>path</b> is a sequence of vertices that are connected by edges. The length of the path is the
                    number of <i>edges</i> in it</li>
                <li>A <b>cycle</b> is a path that starts and ends at the same vertex</li>
                <li>A graph with no cycles is called a <b>acyclic graph</b></li>
                <li>A directed acyclic graph is abbreviated as <b>DAG</b></li>
                <li>A <b>simple path</b> is a path that does not contain any repeated vertices</li>
                <li>
                    A <b>simple cycle</b> is a cycle that does not contain any repeated vertices (except for the first
                    and last vertex)
                </li>
                <li>
                    Two vertices are <b>connected</b> if there is a path between them
                </li>
                <li>
                    A subset of vertices is a <b>connected component</b> if every pair of vertices in the subset is
                    connected
                </li>
                <li>
                    The <b>degree</b> of vertex \(v\) is the number of edges that connect to it
                </li>
            </ul>
            In general, I believe the definitions to be pretty straightforward. It maps pretty well to what you would
            expect it to be.
            <h2 id="L29-Implementation">Implementation</h2>
            There are two common ways to implement the graph ADT.<br><br>

            <ul>
                <li>
                    We can use a <b>Adjacency Matrix</b>, which is a \(n\times n\) matrix where \(\verb#M[i][j]=1#\) if
                    there is an edge between vertex \(i\) and vertex \(j\), and \(\verb#M[i][j]=0#\) otherwise.
                </li>
                <li>
                    We can use an <b>Adjacency List</b>, which is a list of lists where \(\verb#L[i]#\) is a list of all
                    the vertices that are adjacent to vertex \(i\).
                </li>
            </ul>

            <h2 id="L30-adjacency-list">Adjacency List</h2>
            We can implement an adjacency list in Python as follows:
            <pre><code class="python">class Node:
    def __init__(self, data):
        self.data = data
        self.adjacent = []

node1 = Node('TO')
node2 = Node('Ottawa')
node3 = Node('Orlando')

node1.adjacent.append(node2)
node1.adjacent.append(node3)
node2.adjacent.append(node1)
node3.adjacent.append(node1)
</code></pre>
            which gives the following graph:
            <br><br>
            <center>
                <script type="text/tikz">
        \begin{tikzpicture}[scale=3]
        \tikzstyle{vertex}=[circle,fill=black!25,minimum size=40pt,inner sep=2pt]
        \node[vertex] (G_1) at (0,2)  {TO};
        \node[vertex] (G_2) at (0.7,1)  {Ottawa};
        \node[vertex] (G_3) at (-0.7,1)  {Orlando};

        \draw (G_1) -- (G_2);
        \draw (G_1) -- (G_3);
        \end{tikzpicture}
      </script>
            </center>
            For an undirected graph, if there are \(N\) edges, then the sum of the lengths of all the adjacency lists is
            \(2N\).

            <h2 id="L30-adjacency-matrix">Adjacency Matrix</h2>
            We can implement an adjacency matrix in Python by defining the following <i>symmetric</i> matrix (for
            undirected graphs) with \(0\)s on the diagonal:
            \[
            A = \begin{pmatrix}
            0 & 1 & 1 \\
            1 & 0 & 0 \\
            1 & 0 & 0
            \end{pmatrix}
            \]
            where we have labelled \(\verb#TO#\) as node 1, \(\verb#Ottawa#\) as node 2, and \(\verb#Orlando#\) as node
            3. Then the entry \(A_{ij}\) is 1 if there is an edge starting at node \(i\) and ending at node \(j\).
            Recall from linear algebra that \(A_{ij}\) refers to the element in the \(i\)th row and \(j\)th column of
            the matrix \(A\).<br><br>
            <h2 id="L30-pagerank">Pagerank</h2>
            One very notable application of an adjacency matrix is the <b>PageRank</b> algorithm, which is the first and
            most well-known algorithm used by Google to rank web pages. It essentially tries to capture the idea of
            which pages are the most important by asking the following question: If I start at a random page and follow
            random links, what is the probability that I will end up at page \(i\)?
            <ol>
                <li>Normalize the matrix \(A\) to be
                    \[
                    A = \begin{pmatrix}
                    0 & 1/2 & 1/2 \\
                    1 & 0 & 0 \\
                    1 & 0 & 0
                    \end{pmatrix}
                    \]
                    such that each row sums to 1 (i.e. the total probability of ending up at a site when clicking a link
                    is 1).
                </li>
                <li>Imagine that we start at state \(v_0\)</li>
                <li>The probability distribution of reaching some site after a single link click is given by \( M v_0\)
                    where \(M=A^T\). Why is this the case? If the current site is Toronto, then we can write
                    \[
                    v_0 = \begin{pmatrix}
                    1 \\
                    0 \\
                    0
                    \end{pmatrix}
                    \]
                    and the (transpose) adjacency matrix \(M=A^T\) maps this vector to the first row of the matrix,
                    which contains all the sites that Toronto links to.<br><br>

                    In lecture, Professor Guerzhoy wrote \(Av_0\) instead. This gives a different result as the result
                    will be a column that represents the sites that lead to Toronto. For a symmetric adjacency matrix,
                    there is no difference, but in reality, we wouldn't have it to be symmetrical.
                </li>
                <li>
                    Just doing this once is a horrible way of measuring the importance of a site. Someone could cheat
                    the system very easily by creating several sites that all link to the same site. The idea is that if
                    we have a very popular site being linked to by many sites, then many of these sites should also be
                    very popular.<br><br>

                    This idea is reflected by iterating the process of multiplying by \(M=A^T\) several times. Suppose
                    we run it \(k\) times, where \(k\) is some very large number. Surprisingly, the result should
                    actually converge! We get
                    \[
                    (M)^{k} \vec{v}_0 \to \vec{p}
                    \]
                    where \(\vec{p}\) is the probability distribution of reaching any site after \(k\) clicks. This
                    result should not change much depending on what the initial state is (barring some edge cases such
                    as islands), but it is typically done by assuming an initial uniform distribution.<br><br>

                    The \(i^\text{th}\) element of \(\vec{p}\) will then be the page rank of the \(i^\text{th}\) site.
                    The intuition is that if we start at a random site and click links, then the probability of ending
                    up at site \(i\) is equal to the page rank of site \(i\).
                </li>
            </ol>
            Why does this work? Why would we even expect the solution to converge at all? The basic idea is that we can
            decompose \(v_0\) into the eigenvectors \((\vec{w}_1,\vec{w}_2,\dots,\vec{w}_n)\)
            such that
            \[M^{k}\vec{v}_0 = M^k(a_0\vec{w}_1 + \cdots + a_n\vec{w}_n) = a_1\lambda_1^k \vec{w}_1 + \cdots +
            a_n\lambda_n^k \vec{w}_n\]
            Suppose \(\vec{w}_1\) has the largest eigenvalue. Then for large \(k\) we have
            \[M^k\vec{v}_0 \approx a_1\lambda_1^k \vec{w}_1\]
            So we can imagine that if we start at a random site, then the most likely site to end up at is the site with
            the largest eigenvalue.<br><br>

            In fact, it's possible to show (with more linear algebra) that an adjacency matrix where the rows sum to 1
            will always have an eigenvalue of \(1\) with a multiplicity of \(1\). In fact, all other eigenvalues will be
            smaller than \(1\). This shows more clearly that the other eigenvectors will die off quickly as we keep
            iterating. <i>Note:</i> The above was only used to illustrate the intuition you should have for this kind of
            problem.<br><br>

            There are a couple of flaws with this argument (which we need more math to fix), but if this is something
            you are interested in, you cover stuff like this (i.e. Markov chains) more in depth in <b>ECE368</b> (and a
            bit in <b>ROB311</b>) if you decide to do the Machine Intelligence option. <br><br>

            Outside of pagerank, this is a very fundamental idea that allows us to see which nodes are connected.
            <h2 id="L30-graph-implementation">Graph Implementation using Adjacency Matrix</h2>
            We can implement a graph in Python as follows. Note that I have fixed a few minor bugs from lecture.
            <pre><code class="python">class Graph:
    def __init__(self, capacity):
        self.capacity = capacity # The maximum number of nodes
        self.cur_num_nodes = 0 # The current number of nodes
        self.nodes = [] # The list of nodes
        self.indices = {} # A dictionary mapping node names to indices
        self.adj_array = [] # The adjacency array

        # Initialize the adjacency array
        for i in range(self.capacity):
            self.adj_array.append([None] * self.capacity)

    def expand(self):
        '''
        Expand the graph by doubling the capacity.
        '''
        adj_array_new = []
        self.capacity *= 2
        
        # Create a new adjacency array
        for i in range(self.capacity):
            adj_array_new.append([None] * self.capacity)

        # Copy the old adjacency array into the new one
        for i in range(self.cur_num_nodes):
            for j in range(self.cur_num_nodes):
                adj_array_new[i][j] = self.adj_array[i][j]

        self.adj_array = adj_array_new

    def register_node(self, name):
        '''
        Register a new node in the graph.
        '''

        # If the graph is full, expand it
        if self.capacity == self.cur_num_nodes:
            self.expand()

        # Add the node to the graph
        self.nodes.append(name)

        # Add the node to the adjacency array
        self.indices[name] = self.cur_num_nodes

        # Increment the number of nodes
        self.cur_num_nodes += 1

        # Initialize the new row and column
        for i in range(self.cur_num_nodes):
            self.adj_array[i][self.cur_num_nodes-1] = 0
            self.adj_array[self.cur_num_nodes-1][i] = 0
        
    def connect_by_name(self, name1, name2):
        '''
        Connect two nodes in the graph by name.
        '''

        # If either node is not in the graph, add it
        if name1 not in self.indices:
            self.register_node(name1)
        if name2 not in self.indices:
            self.register_node(name2)
        
        # Connect the nodes
        self.connect_by_index(self.indices[name1], self.indices[name2])
        
    def connect_by_index(self, index1, index2):
        '''
        Connect two nodes in the graph by index.
        '''
        self.adj_array[index1][index2] = 1</code></pre>

            <h2 id="L31-adjacency-with-weights">Adjacency Matrix with Weights</h2>
            What if we had an adjacency matrix with weights? Given the below graph,
            <center>
                <script type="text/tikz">
        \begin{tikzpicture}[scale=3]
        \tikzstyle{vertex}=[circle,fill=black!25,minimum size=40pt,inner sep=2pt]
        \node[vertex] (G_3) at (0,0)  {3};
        \node[vertex] (G_0) at (0,1)  {0};
        \node[vertex] (G_2) at (1,0)  {2};
        \node[vertex] (G_1) at (1,1)  {1};

        \draw (G_0) -- (G_3) node[midway,left] {6};
        \draw (G_0) -- (G_1) node[midway, above] {8};
        \draw (G_1) -- (G_2) node[midway, right] {9};
        \end{tikzpicture}
      </script>
            </center>
            the adjacency matrix is
            \[
            A = \begin{bmatrix}
            \infty & 8 & \infty & 6 \\
            8 & \infty & 9 & \infty \\
            \infty & 9 & \infty & \infty \\
            6 & \infty & \infty & \infty\end{bmatrix}
            \]
            where we have \(\infty\) if no edges exist between two nodes.
            <h2 id="L31-adjacency-list-with-ll">Adjacency List with Linked Lists</h2>
            We can also implement an adjacency list with linked lists.
            <center>
                <script type="text/tikz">
        \begin{tikzpicture}
    \tikzstyle{vertex}=[circle, draw, minimum size=20pt]
    \tikzstyle{arrow}=[->,>=stealth]

    % Define the vertices
    \node[vertex] (0) at (1, 1) {0};
    \node[vertex] (1) at (1, 0) {1};
    \node[vertex] (2) at (0, 1) {2};
    \node[vertex] (3) at (3, 2) {3};
    \node[vertex] (4) at (3, 1) {4};
    \node[vertex] (5) at (1, 2) {5};
    \node[vertex] (6) at (0, 0) {6};
    \node[vertex] (7) at (1, 3) {7};
    \node[vertex] (8) at (1, 4) {8};

    % Draw the edges
    \draw[arrow] (1) -- (6);
    \draw[arrow] (2) -- (6);
    \draw[arrow] (0) -- (2);
    \draw[arrow] (7) -- (2);
    \draw[arrow] (0) -- (5);
    \draw[arrow] (5) -- (3);
    \draw[arrow] (3) -- (4);
    \draw[arrow] (4) -- (5);
    \draw[arrow] (5) -- (7);
    \draw[arrow] (7) -- (8);
    \end{tikzpicture}
    </script>
                <script type="text/tikz">
    \begin{tikzpicture}
    \tikzstyle{box}=[rectangle,draw,minimum size=20pt]
    \tikzstyle{arrow}=[->,>=stealth]

    % node 0
        \node[box] at (2*0, 0) {0};
        \node[box] at (2*0+0.75, 0) {};
        \draw[arrow] (2*0+0.75, 0) -- (2*0+1.5, 0);

        \node[box] at (2*1, 0) {2};
        \node[box] at (2*1+0.75, 0) {};
        \draw[arrow] (2*1+0.75, 0) -- (2*1+1.5, 0);

        \node[box] at (2*2, 0) {5};
        \node[box] at (2*2+0.75, 0) {};
    % node 1
        \node[box] at (2* 0, -1) {1};
        \node[box] at (2*0+0.75, -1) {};
        \draw[arrow] (2*0+0.75, -1) -- (2*0+1.5, -1);

        \node[box] at (2*1, -1) {6};
        \node[box] at (2*1+0.75, -1) {};
    % node 2
        \node[box] at (2* 0, -2) {2};
        \node[box] at (2*0+0.75, -2) {};
        \draw[arrow] (2*0+0.75, -2) -- (2*0+1.5, -2);

        \node[box] at (2*1, -2) {6};
        \node[box] at (2*1+0.75, -2) {};
    % node 3
        \node[box] at (2* 0, -3) {3};
        \node[box] at (2*0+0.75, -3) {};
        \draw[arrow] (2*0+0.75, -3) -- (2*0+1.5, -3);

        \node[box] at (2*1, -3) {4};
        \node[box] at (2*1+0.75, -3) {};
    % node 4
        \node[box] at (2* 0, -4) {4};
        \node[box] at (2*0+0.75, -4) {};
        \draw[arrow] (2*0+0.75, -4) -- (2*0+1.5, -4);

        \node[box] at (2*1, -4) {5};
        \node[box] at (2*1+0.75, -4) {};
    % node 5
        \node[box] at (2* 0, -5) {5};
        \node[box] at (2*0+0.75, -5) {};
        \draw[arrow] (2*0+0.75, -5) -- (2*0+1.5, -5);

        \node[box] at (2*1, -5) {3};
        \node[box] at (2*1+0.75, -5) {};
        \draw[arrow] (2*1+0.75, -5) -- (2*1+1.5, -5);

        \node[box] at (2*2, -5) {7};
        \node[box] at (2*2+0.75, -5) {};
    % node 6
        \node[box] at (2* 0, -6) {6};
        \node[box] at (2*0+0.75, -6) {};
     % node 7
        \node[box] at (2* 0, -7) {7};
        \node[box] at (2*0+0.75, -7) {};
        \draw[arrow] (2*0+0.75, -7) -- (2*0+1.5, -7);

        \node[box] at (2*1, -7) {2};
        \node[box] at (2*1+0.75, -7) {};
        \draw[arrow] (2*1+0.75, -7) -- (2*1+1.5, -7);

        \node[box] at (2*2, -7) {8};
        \node[box] at (2*2+0.75, -7) {};
    % node 8
        \node[box] at (2* 0, -8) {8};
        \node[box] at (2*0+0.75, -8) {};
    \end{tikzpicture}
    </script>
            </center>
            This can be useful because it could be more memory efficient, allows the size to be resized easily, and
            accessing the neighbours is very straightforward.
            <h2 id="L31-complexity">Complexity</h2>
            Using an adjacency matrix versus an adjacency matrix has certain trade-offs. The two most common operations
            is checking if there is an edge between \(v_i\) and \(v_j\) as well as finding all the vertices adjacent to
            a vertex \(v_i\)
            <ul>
                <li>Detecting if edge exists</li>
                <ul>
                    <li>Adjacency Matrix: O(1). This is because we can directly access the element in the matrix.</li>

                    <li>Adjacency List: O(d) where \(d\) is the maximum degree in the graph. This is because we have to
                        traverse the linked list to find the edge.</li>
                </ul>
                <li>
                    Finding all neighbours
                </li>
                <ul>
                    <li>Adjacency Matrix: \(O(|V|)\) where \(|V|\) is the number of vertices. This is because we have to
                        traverse the entire row.</li>
                    <li>
                        Adjacency List: \(O(d)\) where \(d\) is the maximum degree in the graph. This is because we have
                        to traverse the linked list to find the edge.
                    </li>
                </ul>
            </ul>
            When \(d\) is much smaller than \(|V|\) it's clear that the adjacency list is more efficient. However, when
            \(d\) is close to \(|V|\) then the adjacency matrix is more efficient.<br><br>

            We also have to think about space requirements. An adjacency matrix needs a space of \(O(|V|^2)\) because
            this is the number of entries in the matrix.<br><br>

            An adjacency list has a space requirement of \(O(|E| + |V|)\). This is slightly trickier to figure out why.
            This is because we want to store a total of \(|V|\) vertices. For each of the \(|V|\) vertices, we want to
            store a linked list such that the total number of elements of the lined lists is equal to \(E\) (or \(2E\)
            for an undirected graph). Therefore, we have a space requirement of \(O(|E| + |V|)\).

        </div>
    </div>
    <footer>
        By Michael Guerzhoy, Youssef Rachad, Ian Wu, Qilin Xue<br>
        &copy; 2023 Sharing, re-distribution, and adaptation is allowed for non-commercial purposes as long as
        attribution to the original author is given, and as long as you notify the original author at
        guerzhoy@cs.toronto.edu that you intend to use the materials. Atrribution must be given in a reasonable way and
        in a way that does not suggest that the original author endorses any adaptation. This permission to share,
        re-distribute and adapt is non-transferrable.
    </footer>
    </div>
</body>

</html>